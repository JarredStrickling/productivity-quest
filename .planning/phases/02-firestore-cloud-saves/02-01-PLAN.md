---
phase: 02-firestore-cloud-saves
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/utils/saveManager.js
  - firestore.rules
autonomous: true
requirements: [ACCT-04]

must_haves:
  truths:
    - "saveCharacter writes a full playerStats object to Firestore at users/{uid}/characters/{slotId}"
    - "loadCharacterSlots reads both character slots from Firestore and returns { 1: data|null, 2: data|null }"
    - "deleteCharacterSlot removes the Firestore document and cleans up the legacy localStorage key"
    - "saveWithRetry retries up to 3 times with exponential backoff and calls a warning callback on final failure"
    - "Security rules enforce owner-only access, XP monotonic increase capped at 200 per write, level increase capped at 1 per write"
  artifacts:
    - path: "src/utils/saveManager.js"
      provides: "Firestore save/load/delete character functions with retry logic"
      exports: ["saveCharacter", "loadCharacterSlots", "deleteCharacterSlot", "saveWithRetry"]
    - path: "firestore.rules"
      provides: "Firestore security rules for characters, sessions, users, usernames"
      contains: "request.resource.data.xp >= resource.data.xp"
  key_links:
    - from: "src/utils/saveManager.js"
      to: "src/firebase.js"
      via: "import { db }"
      pattern: "import.*db.*from.*firebase"
    - from: "src/utils/saveManager.js"
      to: "firebase/firestore"
      via: "setDoc, getDocs, deleteDoc, serverTimestamp"
      pattern: "import.*setDoc.*from.*firebase/firestore"
---

<objective>
Create the Firestore data layer for character saves — utility functions for save/load/delete with retry logic, and security rules that enforce ownership and anti-cheat constraints.

Purpose: This is the foundation that all other Phase 2 plans depend on. Without these utilities, nothing can read or write character data to Firestore.
Output: `src/utils/saveManager.js` (4 exported functions) and `firestore.rules` (deployable security rules)
</objective>

<execution_context>
@C:/Users/jarre/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/jarre/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-firestore-cloud-saves/02-RESEARCH.md

# Phase 1 established the Firebase singleton — db is already exported from src/firebase.js
@src/firebase.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create saveManager utility with Firestore save/load/delete and retry</name>
  <files>src/utils/saveManager.js</files>
  <action>
Create `src/utils/saveManager.js` with four exported functions:

1. **`saveCharacter(uid, slotId, stats)`** — Fire-and-forget write (do NOT await in callers).
   - Path: `doc(db, 'users', uid, 'characters', String(slotId))`
   - Use `setDoc(ref, { ...stats, savedAt: serverTimestamp() })` — full overwrite, no merge needed (always writing complete playerStats object).
   - Return the Promise (callers use `.catch()` or pass to `saveWithRetry`).
   - Import `db` from `'../firebase'`.

2. **`loadCharacterSlots(uid)`** — Returns `{ 1: characterData|null, 2: characterData|null }`.
   - Use `getDocs(collection(db, 'users', uid, 'characters'))`.
   - Iterate snapshot, map `docSnap.id` (string "1" or "2") to slot number.
   - Only accept slotId 1 or 2 (ignore unexpected documents).
   - This function IS awaited (needed before showing slot UI).

3. **`deleteCharacterSlot(uid, slotId)`** — Deletes the Firestore document and cleans up legacy localStorage.
   - `await deleteDoc(doc(db, 'users', uid, 'characters', String(slotId)))`.
   - Also call `localStorage.removeItem('saveSlot' + slotId)` for legacy cleanup.

4. **`saveWithRetry(uid, slotId, stats, onWarning, attempt = 0)`** — Wraps `saveCharacter` with exponential backoff retry.
   - On success: call `onWarning(false)` to clear any active warning.
   - On failure: if `attempt < 3`, retry after `Math.pow(2, attempt) * 1000` ms (1s, 2s, 4s).
   - After 3 failures: call `onWarning(true)` to show "Cloud save unavailable" warning.
   - Use `setTimeout` for delay — not `await` with sleep.

Import from `firebase/firestore`: `doc, collection, setDoc, getDocs, deleteDoc, serverTimestamp`.
Import `db` from `'../firebase'`.

Do NOT use `{ merge: true }` — the game always writes the complete playerStats object, and full overwrite prevents stale field drift.

Per research pitfall #1: callers should NOT await `saveCharacter` in event handlers — it hangs offline. The `saveWithRetry` wrapper handles the error path.
  </action>
  <verify>
Run `npm run build` — the file should compile with no import errors. Manually inspect the file to confirm 4 named exports exist and all Firestore imports resolve.
  </verify>
  <done>
`src/utils/saveManager.js` exists with 4 exported functions (saveCharacter, loadCharacterSlots, deleteCharacterSlot, saveWithRetry). All use the Firestore subcollection path `users/{uid}/characters/{slotId}`. saveCharacter is fire-and-forget. saveWithRetry has exponential backoff with warning callback.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Firestore security rules file</name>
  <files>firestore.rules</files>
  <action>
Create `firestore.rules` at the project root with the following rules:

```
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Username lookup — readable by anyone (login resolution); writable by authenticated users (registration)
    match /usernames/{usernameLower} {
      allow read: if true;
      allow write: if request.auth != null;
    }

    // User profiles — owner only
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;

      // Character save slots — owner only, constrained fields on create/update
      match /characters/{slotId} {
        allow read: if request.auth != null && request.auth.uid == userId;

        // New character must start at level 1, XP 0
        allow create: if request.auth != null
          && request.auth.uid == userId
          && request.resource.data.level == 1
          && request.resource.data.xp == 0;

        // Updates: XP can only increase (max +200 per write — Legendary=150, buffer for edge cases),
        // level can only go up by 1 per write, max level 100
        allow update: if request.auth != null
          && request.auth.uid == userId
          && request.resource.data.xp >= resource.data.xp
          && (request.resource.data.xp - resource.data.xp) <= 200
          && request.resource.data.level >= resource.data.level
          && request.resource.data.level <= 100
          && (request.resource.data.level - resource.data.level) <= 1;

        allow delete: if request.auth != null && request.auth.uid == userId;
      }
    }

    // Session locks — owner only, no field constraints (just auth ownership)
    match /sessions/{userId} {
      allow read, write, delete: if request.auth != null && request.auth.uid == userId;
    }
  }
}
```

Note: XP cap set to 200 (Legendary tier is 150 XP, +50 buffer). The research suggested 500 but actual max is 150. 200 gives reasonable headroom without being exploitable.

This file is deployed manually to Firebase Console or via `firebase deploy --only firestore:rules`. It is NOT consumed by the client code but must be in the repo for version control.
  </action>
  <verify>
Verify the file exists at the project root. Check that the rules syntax is valid (balanced braces, correct `match` nesting). The file cannot be tested locally without the Firebase emulator, but structural correctness can be visually confirmed.
  </verify>
  <done>
`firestore.rules` exists at project root with: owner-only character reads/writes, create constraint (level=1, xp=0), update constraint (XP monotonic +200 cap, level +1 cap), session lock rules (owner-only), username rules (public read, auth write). Rules are ready for deployment.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes — saveManager imports resolve correctly
2. `src/utils/saveManager.js` exports: saveCharacter, loadCharacterSlots, deleteCharacterSlot, saveWithRetry
3. `firestore.rules` has valid structure with no syntax errors
4. saveCharacter uses fire-and-forget pattern (no await in the function body for the setDoc call)
5. XP cap in rules matches actual game max (200, covering 150 Legendary + buffer)
</verification>

<success_criteria>
The Firestore data layer is complete: utility functions can save/load/delete characters to Firestore, retry logic handles transient failures with user-facing warnings, and security rules enforce ownership and anti-cheat constraints. No existing files are modified in this plan.
</success_criteria>

<output>
After completion, create `.planning/phases/02-firestore-cloud-saves/02-01-SUMMARY.md`
</output>
