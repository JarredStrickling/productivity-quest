---
phase: 02-firestore-cloud-saves
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/useSessionLock.jsx
  - src/hooks/useConnection.jsx
  - src/components/ConnectionOverlay.jsx
  - src/components/ConnectionOverlay.css
autonomous: true
requirements: [ACCT-05]

must_haves:
  truths:
    - "Only one browser tab/device can play on a given account at a time — a second device sees a blocked message"
    - "Session lock auto-expires after 5 minutes if the user closes the tab without logging out"
    - "Logging out clears the session lock immediately so another device can play"
    - "A session heartbeat renews the lock every 2 minutes on active sessions"
    - "When the browser goes offline mid-session, a full-screen overlay freezes gameplay"
    - "When the browser comes back online, the overlay disappears and gameplay resumes automatically"
  artifacts:
    - path: "src/hooks/useSessionLock.jsx"
      provides: "Session lock management — acquire, release, heartbeat, blocked state"
      exports: ["useSessionLock"]
    - path: "src/hooks/useConnection.jsx"
      provides: "Online/offline status detection"
      exports: ["useConnection"]
    - path: "src/components/ConnectionOverlay.jsx"
      provides: "Full-screen connection lost overlay"
      exports: ["default"]
    - path: "src/components/ConnectionOverlay.css"
      provides: "Overlay styling — covers entire viewport, blocks pointer events"
      contains: "pointer-events"
  key_links:
    - from: "src/hooks/useSessionLock.jsx"
      to: "src/firebase.js"
      via: "import { db }"
      pattern: "import.*db.*from.*firebase"
    - from: "src/hooks/useSessionLock.jsx"
      to: "firebase/firestore"
      via: "doc, setDoc, getDoc, deleteDoc, serverTimestamp"
      pattern: "import.*setDoc.*from.*firebase/firestore"
    - from: "src/hooks/useConnection.jsx"
      to: "window online/offline events"
      via: "addEventListener"
      pattern: "addEventListener.*online"
---

<objective>
Create the session lock mechanism (one active session per account) and connection monitoring (freeze overlay when offline).

Purpose: Session locking prevents multi-device write conflicts. Connection monitoring ensures the game freezes on disconnect rather than silently losing saves. Together, these enable safe multi-device access (ACCT-05).
Output: `useSessionLock` hook, `useConnection` hook, `ConnectionOverlay` component
</objective>

<execution_context>
@C:/Users/jarre/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/jarre/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-firestore-cloud-saves/02-RESEARCH.md

# Firebase singleton — db already exported
@src/firebase.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useSessionLock hook with acquire/release/heartbeat</name>
  <files>src/hooks/useSessionLock.jsx</files>
  <action>
Create `src/hooks/useSessionLock.jsx` exporting a `useSessionLock` custom hook.

**Constants (module-level):**
- `SESSION_TIMEOUT_MS = 5 * 60 * 1000` (5 minutes — per research recommendation)
- `HEARTBEAT_INTERVAL_MS = 2 * 60 * 1000` (2 minutes)
- `deviceId = crypto.randomUUID()` — generated once per module load, stable for the tab's lifetime

**Hook signature:** `useSessionLock(uid)` where `uid` is the authenticated user's UID (from `useAuth`). Returns `{ isBlocked, isCheckingLock, acquireLock, releaseLock }`.

**State:**
- `isBlocked` (boolean, default false) — true when another session holds the lock
- `isCheckingLock` (boolean, default true) — true while the initial lock check is in progress

**`acquireLock()` (async):**
1. Set `isCheckingLock(true)`.
2. Read `sessions/{uid}` via `getDoc`.
3. If document exists:
   - Get `lockedAt` timestamp: `data.lockedAt?.toDate?.() ?? new Date(0)`.
   - Compute age: `Date.now() - lockedAt.getTime()`.
   - If `age < SESSION_TIMEOUT_MS` AND `data.deviceId !== deviceId` — set `isBlocked(true)`, `isCheckingLock(false)`, return.
4. Write lock: `setDoc(doc(db, 'sessions', uid), { deviceId, lockedAt: serverTimestamp() })`.
5. Set `isBlocked(false)`, `isCheckingLock(false)`.
6. Start heartbeat interval.

**Heartbeat (via `useEffect` cleanup):**
- `setInterval` every `HEARTBEAT_INTERVAL_MS` — write `{ deviceId, lockedAt: serverTimestamp() }` to `sessions/{uid}`.
- Clear interval on unmount or when `uid` changes.
- Only run heartbeat if not blocked.

**`releaseLock()` (async):**
- `deleteDoc(doc(db, 'sessions', uid))`.
- Clear heartbeat interval.

**`useEffect` on uid:**
- When `uid` is truthy, call `acquireLock()`.
- When `uid` is falsy (logout), call `releaseLock()`.
- Cleanup: call `releaseLock()` on unmount.

**Also add `beforeunload` listener:**
- On `window.beforeunload`, do NOT release the lock (the heartbeat timeout handles tab-close expiry). This is intentional — `deleteDoc` in `beforeunload` is unreliable and could leave the lock deleted while the tab is still open.

Import `doc, setDoc, getDoc, deleteDoc, serverTimestamp` from `'firebase/firestore'`.
Import `db` from `'../firebase'`.

Use `.jsx` extension (not `.js`) — Vite requires `.jsx` for files with JSX. This hook uses no JSX but follow the project convention from Phase 1 where all hooks use `.jsx`.
  </action>
  <verify>
Run `npm run build` — the file should compile with no errors. Verify the hook exports `useSessionLock`. Inspect that heartbeat interval is properly cleared on cleanup.
  </verify>
  <done>
`src/hooks/useSessionLock.jsx` exists and exports `useSessionLock(uid)` returning `{ isBlocked, isCheckingLock, acquireLock, releaseLock }`. Lock timeout is 5 minutes, heartbeat interval is 2 minutes, `deviceId` is generated once per tab via `crypto.randomUUID()`. Lock is acquired on mount, released on unmount/logout.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useConnection hook and ConnectionOverlay component</name>
  <files>
    src/hooks/useConnection.jsx
    src/components/ConnectionOverlay.jsx
    src/components/ConnectionOverlay.css
  </files>
  <action>
**useConnection hook (`src/hooks/useConnection.jsx`):**

Export `useConnection` — a simple hook that tracks `navigator.onLine`.

- State: `isOnline` (boolean, initialized from `navigator.onLine`).
- `useEffect`: add `online` and `offline` event listeners on `window`. Update `isOnline` state. Cleanup removes listeners.
- Return `isOnline`.

**ConnectionOverlay component (`src/components/ConnectionOverlay.jsx`):**

A full-screen overlay that renders when `isOnline` is false and the user is in-game.

Props: `visible` (boolean) — parent controls when to show it.

Render:
```jsx
if (!visible) return null;
return (
  <div className="connection-overlay">
    <div className="connection-overlay-content">
      <p className="connection-overlay-text">Connection lost. Reconnecting...</p>
    </div>
  </div>
);
```

**ConnectionOverlay CSS (`src/components/ConnectionOverlay.css`):**

```css
.connection-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.85);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10000;
  pointer-events: all;
}

.connection-overlay-content {
  text-align: center;
  padding: 2rem;
}

.connection-overlay-text {
  color: #f4e4c1;
  font-size: 1.5rem;
  font-family: 'Georgia', serif;
}
```

Key CSS properties:
- `z-index: 10000` — must be above all game UI and modals.
- `pointer-events: all` — blocks ALL input to the Phaser canvas and React UI underneath.
- `position: fixed` — covers the entire viewport even if content scrolls.
- RPG parchment color `#f4e4c1` for text — consistent with the project's visual theme.
  </action>
  <verify>
Run `npm run build` — all three files compile. Verify `useConnection` exports correctly and `ConnectionOverlay` imports its CSS file.
  </verify>
  <done>
`src/hooks/useConnection.jsx` exports `useConnection()` returning `isOnline` boolean. `src/components/ConnectionOverlay.jsx` renders a full-screen dark overlay with "Connection lost. Reconnecting..." text. CSS blocks all pointer events and uses RPG parchment color theme. Overlay is controlled by `visible` prop — parent decides when to show it.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes — all 4 new files compile without import errors
2. `useSessionLock` exports: acquireLock, releaseLock, isBlocked, isCheckingLock
3. `useConnection` exports: isOnline boolean
4. `ConnectionOverlay` renders only when `visible` is true
5. Heartbeat interval is started on lock acquire and cleared on release/unmount
6. CSS overlay covers full viewport with pointer-events blocking
</verification>

<success_criteria>
Session lock and connection monitoring infrastructure is complete. The useSessionLock hook can acquire/release/heartbeat a per-user lock in Firestore. The useConnection hook detects online/offline state. The ConnectionOverlay component provides the visual freeze UI. None of these are wired into App.jsx yet — that happens in Plan 03.
</success_criteria>

<output>
After completion, create `.planning/phases/02-firestore-cloud-saves/02-02-SUMMARY.md`
</output>
