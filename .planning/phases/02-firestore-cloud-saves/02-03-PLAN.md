---
phase: 02-firestore-cloud-saves
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - src/components/SaveSlotSelection.jsx
  - src/components/MainMenu.jsx
  - src/App.jsx
  - src/App.css
autonomous: false
requirements: [ACCT-04, ACCT-05]

must_haves:
  truths:
    - "SaveSlotSelection loads character slots from Firestore (not localStorage) via loadCharacterSlots"
    - "SaveSlotSelection delete calls deleteCharacterSlot (Firestore delete + localStorage cleanup)"
    - "MainMenu receives slot data from parent — no longer reads localStorage directly"
    - "All save events in App.jsx (task submit, stat allocate, character create) call saveWithRetry instead of localStorage.setItem"
    - "Session lock gate blocks game access when another device holds the lock"
    - "Connection overlay appears during offline and freezes all gameplay"
    - "Old localStorage save data is cleaned up on login"
    - "handleNewGame finds empty slots from Firestore data, not localStorage"
    - "handleLoadGame no longer reads localStorage — receives pre-loaded slot data"
    - "handleLogout releases the session lock before signing out"
  artifacts:
    - path: "src/components/SaveSlotSelection.jsx"
      provides: "Firestore-backed save slot UI with loading/error states"
      contains: "loadCharacterSlots"
    - path: "src/components/MainMenu.jsx"
      provides: "Main menu with slot-full check from Firestore data prop"
      contains: "saveSlots"
    - path: "src/App.jsx"
      provides: "Firestore-wired game orchestrator with session lock and connection overlay"
      contains: "saveWithRetry"
    - path: "src/App.css"
      provides: "Styles for session blocked screen and save warning"
      contains: "session-blocked"
  key_links:
    - from: "src/App.jsx"
      to: "src/utils/saveManager.js"
      via: "import { saveWithRetry, loadCharacterSlots }"
      pattern: "import.*saveWithRetry.*from.*saveManager"
    - from: "src/App.jsx"
      to: "src/hooks/useSessionLock.jsx"
      via: "import { useSessionLock }"
      pattern: "import.*useSessionLock.*from.*useSessionLock"
    - from: "src/App.jsx"
      to: "src/hooks/useConnection.jsx"
      via: "import { useConnection }"
      pattern: "import.*useConnection.*from.*useConnection"
    - from: "src/App.jsx"
      to: "src/components/ConnectionOverlay.jsx"
      via: "import ConnectionOverlay"
      pattern: "import ConnectionOverlay"
    - from: "src/components/SaveSlotSelection.jsx"
      to: "src/utils/saveManager.js"
      via: "import { loadCharacterSlots, deleteCharacterSlot }"
      pattern: "import.*loadCharacterSlots.*from.*saveManager"
    - from: "src/components/MainMenu.jsx"
      to: "props.saveSlots"
      via: "saveSlots prop from App.jsx"
      pattern: "saveSlots"
---

<objective>
Rewire the entire game from localStorage to Firestore: save slot UI reads Firestore, all save events write to Firestore via saveWithRetry, session lock gates game access, connection overlay freezes gameplay on disconnect, and old localStorage data is cleaned up.

Purpose: This is the integration plan that makes cloud saves real. Plans 01 and 02 built the utilities; this plan connects them to the existing game.
Output: Modified SaveSlotSelection.jsx, MainMenu.jsx, App.jsx, App.css — localStorage is no longer used for saves.
</objective>

<execution_context>
@C:/Users/jarre/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/jarre/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-firestore-cloud-saves/02-RESEARCH.md
@.planning/phases/02-firestore-cloud-saves/02-01-SUMMARY.md
@.planning/phases/02-firestore-cloud-saves/02-02-SUMMARY.md

# Current state of files being modified
@src/App.jsx
@src/components/SaveSlotSelection.jsx
@src/components/MainMenu.jsx
@src/hooks/useAuth.jsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewire SaveSlotSelection and MainMenu to Firestore</name>
  <files>
    src/components/SaveSlotSelection.jsx
    src/components/MainMenu.jsx
  </files>
  <action>
**SaveSlotSelection.jsx — Full rewrite of data source:**

1. Remove all `localStorage.getItem` and `localStorage.setItem` calls.
2. Add props: `uid` (string, from App.jsx via useAuth).
3. Import `{ loadCharacterSlots, deleteCharacterSlot }` from `'../utils/saveManager'`.
4. Replace `loadSlots()` function:
   - Set a `loading` state (boolean, default true) and `error` state (string|null, default null).
   - `loadSlots` is now async: calls `await loadCharacterSlots(uid)`.
   - Converts the returned `{ 1: data|null, 2: data|null }` object into the existing `[{ slotId, data }]` array format that the render expects.
   - On error: set `error` to a user-facing message, set `loading(false)`.
   - On success: set `saveSlots` state, set `loading(false)`.
5. `useEffect` calls `loadSlots()` on mount (dependency: `[uid]`).
6. Add loading state render: while `loading` is true, show a centered spinner or "Loading saves..." text (use the existing RPG parchment theme).
7. Add error state render: if `error` is set, show the error message with a "Retry" button that calls `loadSlots()` again.
8. Replace `handleDelete`:
   - Call `await deleteCharacterSlot(uid, slot.slotId)` instead of `localStorage.removeItem`.
   - Then call `loadSlots()` to refresh the list.
   - Wrap in try/catch — on error, alert the user.

**MainMenu.jsx — Remove localStorage dependency:**

1. Remove the `areSlotsFullFn()` function entirely.
2. Add new props: `saveSlots` (the `{ 1: data|null, 2: data|null }` object from App.jsx) and `uid` (string).
3. Compute `slotsFull` from props: `Object.values(saveSlots).every(s => s !== null)`.
4. When `onBack` is called from SaveSlotSelection, App.jsx will re-fetch slots and pass updated `saveSlots` — no need for MainMenu to recalculate from localStorage.
5. Pass `uid` prop through to `SaveSlotSelection`.
6. Remove the `slotsFull` state — derive it directly from props.
7. Keep `showSaveSlots` local state for toggling the view.
  </action>
  <verify>
Run `npm run build` — both files compile. Verify that `localStorage.getItem` and `localStorage.setItem` no longer appear in either file (except the legacy cleanup in deleteCharacterSlot which is in saveManager.js). Confirm SaveSlotSelection accepts `uid` prop and MainMenu accepts `saveSlots` and `uid` props.
  </verify>
  <done>
SaveSlotSelection loads from Firestore via `loadCharacterSlots(uid)` with loading/error states. Delete calls `deleteCharacterSlot(uid, slotId)`. MainMenu derives `slotsFull` from `saveSlots` prop — zero localStorage reads. Both components accept `uid` prop for Firestore operations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Rewire App.jsx — Firestore saves, session lock, connection overlay, localStorage cleanup</name>
  <files>
    src/App.jsx
    src/App.css
  </files>
  <action>
This is the largest task in Phase 2. Modify `src/App.jsx` to replace ALL localStorage save operations with Firestore and integrate session lock + connection monitoring.

**New imports (add at top):**
```javascript
import { saveWithRetry, loadCharacterSlots } from './utils/saveManager'
import { useSessionLock } from './hooks/useSessionLock'
import { useConnection } from './hooks/useConnection'
import ConnectionOverlay from './components/ConnectionOverlay'
```

**New state:**
- `saveSlots` state: `useState({ 1: null, 2: null })` — holds loaded Firestore slot data for MainMenu.
- `saveWarning` state: `useState(false)` — true when save retries exhausted.
- `slotsLoaded` state: `useState(false)` — true after initial Firestore slot load completes.

**New hooks (call near top of component, after useAuth):**
- `const { isBlocked, isCheckingLock, releaseLock } = useSessionLock(currentUser?.uid)`
- `const isOnline = useConnection()`

**Load save slots from Firestore on login:**
Add a `useEffect` that fires when `currentUser` becomes truthy:
```javascript
useEffect(() => {
  if (!currentUser) {
    setSaveSlots({ 1: null, 2: null });
    setSlotsLoaded(false);
    return;
  }
  let cancelled = false;
  async function load() {
    try {
      const slots = await loadCharacterSlots(currentUser.uid);
      if (!cancelled) {
        setSaveSlots(slots);
        setSlotsLoaded(true);
      }
    } catch (err) {
      console.error('Failed to load save slots:', err);
      if (!cancelled) setSlotsLoaded(true); // Show UI even on error — slots will appear empty
    }
  }
  load();
  return () => { cancelled = true; };
}, [currentUser]);
```

**Clean up old localStorage on login:**
Inside the same effect or a separate one, unconditionally remove legacy keys:
```javascript
localStorage.removeItem('saveSlot1');
localStorage.removeItem('saveSlot2');
localStorage.removeItem('playerStats');
```
This ensures no stale localStorage data can confuse any remaining reads.

**Replace localStorage.setItem in handleTaskSubmit:**
Remove: `localStorage.setItem(slotKey, JSON.stringify(newStats))`
Replace with: `saveWithRetry(currentUser.uid, currentSaveSlot || 1, newStats, setSaveWarning)`

**Replace localStorage.setItem in handleAllocateStat:**
Remove: `localStorage.setItem(slotKey, JSON.stringify(newStats))`
Replace with: `saveWithRetry(currentUser.uid, currentSaveSlot || 1, newStats, setSaveWarning)`

**Replace localStorage.setItem in handleCharacterCreation:**
Remove: `localStorage.setItem(slotKey, JSON.stringify(newStats))`
Replace with: `saveWithRetry(currentUser.uid, currentSaveSlot || 1, newStats, setSaveWarning)`
Also update `saveSlots` state after creation: `setSaveSlots(prev => ({ ...prev, [currentSaveSlot || 1]: newStats }))`.

**Replace localStorage reads in handleNewGame:**
Remove the `for` loop that calls `localStorage.getItem('saveSlot' + i)`.
Replace with: find first empty slot from `saveSlots` state:
```javascript
let slotToUse = slotId;
if (!slotToUse) {
  slotToUse = 1;
  for (let i = 1; i <= 2; i++) {
    if (!saveSlots[i]) {
      slotToUse = i;
      break;
    }
  }
}
```

**Remove the old localStorage migration useEffect:**
Delete the entire `useEffect` that migrates `'playerStats'` to `'saveSlot1'` (lines 373-387 in current App.jsx). This migration is no longer needed — cloud starts fresh.

**Update handleLogout:**
Before calling `await logout()`, call `await releaseLock()` to immediately clear the session lock. This unblocks other devices:
```javascript
const handleLogout = async () => {
  const confirmed = window.confirm('Are you sure you want to log out?');
  if (!confirmed) return;
  // Reset game state (existing code)...
  await releaseLock();
  await logout();
};
```

**Auth gate rendering — add session lock check and connection overlay:**

After the existing splash screen early return, add two new stages:

```javascript
// Stage 1.5: Session lock check — show while checking lock status
if (currentUser && isCheckingLock) {
  return <SplashScreen />; // Reuse splash as a loading screen
}

// Stage 1.6: Session blocked — another device is active
if (currentUser && isBlocked) {
  return (
    <div className="session-blocked">
      <div className="session-blocked-content">
        <h2>Session Active Elsewhere</h2>
        <p>You're playing on another device. Log out there first.</p>
        <button className="session-blocked-logout" onClick={handleLogout}>
          Log Out Here
        </button>
      </div>
    </div>
  );
}
```

Place these AFTER the splash/auth gate checks but BEFORE the main game render.

**Add connection overlay in Stage 3 (game UI):**
Inside the game render (after `<div className="app-container">`), add:
```jsx
<ConnectionOverlay visible={!isOnline} />
```

**Add save warning in Stage 3:**
If `saveWarning` is true, render a non-blocking warning banner:
```jsx
{saveWarning && (
  <div className="save-warning">Cloud save unavailable — progress may not be saved</div>
)}
```

**Pass saveSlots and uid to MainMenu:**
Update the MainMenu render to pass the new props:
```jsx
<MainMenu
  onNewGame={handleNewGame}
  onLoadGame={handleLoadGame}
  saveSlots={saveSlots}
  uid={currentUser?.uid}
/>
```

**App.css additions:**

Add styles for the session blocked screen:
```css
.session-blocked {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: #1a0e08;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}

.session-blocked-content {
  text-align: center;
  padding: 2rem;
  max-width: 400px;
}

.session-blocked-content h2 {
  color: #f4e4c1;
  font-family: 'Georgia', serif;
  font-size: 1.5rem;
  margin-bottom: 1rem;
}

.session-blocked-content p {
  color: #a08050;
  font-size: 1.1rem;
  margin-bottom: 2rem;
}

.session-blocked-logout {
  background: #8b3030;
  color: #f4e4c1;
  border: 2px solid #a08050;
  padding: 0.75rem 2rem;
  font-size: 1rem;
  font-family: 'Georgia', serif;
  border-radius: 6px;
  cursor: pointer;
}

.session-blocked-logout:hover {
  background: #a03838;
}

.save-warning {
  position: fixed;
  bottom: 1rem;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(139, 48, 48, 0.9);
  color: #f4e4c1;
  padding: 0.5rem 1.5rem;
  border-radius: 6px;
  font-size: 0.9rem;
  z-index: 9000;
  pointer-events: none;
}
```
  </action>
  <verify>
Run `npm run build` — App.jsx compiles. Verify:
1. ZERO occurrences of `localStorage.setItem` or `localStorage.getItem` remain in App.jsx (except inside the cleanup `removeItem` calls).
2. `saveWithRetry` is called in handleTaskSubmit, handleAllocateStat, and handleCharacterCreation.
3. `useSessionLock` and `useConnection` are called in the component body.
4. ConnectionOverlay is rendered in the game UI.
5. Session blocked screen renders when `isBlocked` is true.
6. `releaseLock()` is called in handleLogout before `logout()`.
  </verify>
  <done>
App.jsx is fully wired to Firestore. All 3 save events (task submit, stat allocate, character create) use `saveWithRetry`. Save slots load from Firestore on login. Session lock gates game access with a blocked screen. Connection overlay freezes gameplay when offline. Old localStorage data is cleaned up on login. Logout releases the session lock before signing out. No localStorage reads/writes remain for save data.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: End-to-end cloud save verification</name>
  <files>n/a</files>
  <action>
Human verifies the complete Firestore cloud save system end-to-end.

What was built: Complete Firestore cloud save system — character saves stored in Firestore, session lock prevents multi-device conflicts, connection overlay freezes gameplay on disconnect, old localStorage data cleaned up.

Prerequisites: Firebase project with Firestore enabled, valid `.env` with Firebase config, deploy `firestore.rules` via Firebase Console or CLI.

Verification steps:

1. Fresh login — empty slots: Open the app, log in with an existing account. Main Menu should show "New Game" enabled and save slots should be empty (no carryover from localStorage).

2. Create a character: Click "New Game", create a character in slot 1. Check Firebase Console > Firestore > `users/{uid}/characters/1` — document should exist with `level: 1, xp: 0, savedAt: (timestamp)`.

3. Persistence across refresh: Refresh the browser (F5). Log back in — the character should appear in slot 1 with the same stats.

4. Save on XP gain: Submit a task and gain XP. Check Firestore — `xp` value should update in the document.

5. Multi-device session lock: Open the app in a second browser/incognito window, log in with the same account. The second window should show "You're playing on another device. Log out there first."

6. Logout releases lock: Log out from the first window. Refresh the second window — it should now be able to play.

7. Connection overlay (optional — requires network throttle): Open Chrome DevTools > Network tab > set to "Offline". A dark overlay should appear: "Connection lost. Reconnecting..." Set back to "Online" — overlay should disappear.

8. Delete character: Delete the character from the save slot screen. Verify the Firestore document is gone in Firebase Console.

Resume signal: Type "approved" or describe issues found.
  </action>
  <verify>User confirms all 8 verification steps pass, or reports issues for gap closure.</verify>
  <done>All cloud save features verified working: Firestore persistence, cross-device access, session lock, connection overlay, character delete, localStorage cleanup.</done>
</task>

</tasks>

<verification>
1. `npm run build` passes
2. No `localStorage.setItem` for save data in App.jsx
3. No `localStorage.getItem` for save data in SaveSlotSelection.jsx or MainMenu.jsx
4. Firestore documents created at `users/{uid}/characters/{slotId}` on character creation
5. Save data persists across browser refresh via Firestore
6. Session lock blocks second device
7. Connection overlay appears on network loss
8. Security rules deployed and preventing XP manipulation
</verification>

<success_criteria>
The complete cloud save system is live: characters save to Firestore on every significant event, load from Firestore on login, persist across devices, are protected by session lock and security rules, and gameplay freezes on connection loss. localStorage is no longer used for save data.
</success_criteria>

<output>
After completion, create `.planning/phases/02-firestore-cloud-saves/02-03-SUMMARY.md`
</output>
